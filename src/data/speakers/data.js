import JennaImage from "../../img/JennaZeigen.jpeg";
import DineshImage from "../../img/dinesh.jpeg";
import AngieImage from "../../img/angie.jpeg"
import AlexImage from "../../img/alex.jpeg"
import LindseyImage from "../../img/lindsey.jpeg"

export default [{
    name: 'Jenna Ziegen',
    handle: 'zeigenvector',
    img: JennaImage,
    title: 'Parsing Parsers',
    description: 'Have you ever wondered how your code goes from being characters in a file to something that the computer can "understand" and do something with? A key part of this is the parser. In this talk, we’ll look at building a search query parser (all in JavaScript, of course). On this journey, we’ll first take a step back and learn about the building blocks of all languages, from letters to grammars, and how they represent meaning. Then, we’ll talk about what a parser is and does and why we might want one for our task. With this new knowledge, we’ll dive into building the parser, from tokenizing to building a data structure that represents the query and lets us build a UI around it.'
  },
  {
    name: 'Dinesh Pandiyan',
    handle: 'flexdinesh',
    img: DineshImage,
    title: 'Progressive Rendering — Improve web application performance on slower networks',
    description: 'Modern web applications have become increasingly costly in terms of size resulting in slower page load times in slower networks. Client Side Rendering (CSR) becomes a bottleneck in slower networks whereas Server Side Rendering (SSR) becomes a bottleneck when large volumes of content need to be generated in one-go. Progressive rendering is a technique that allows us to flush portions of a webpage to the browser in chunks as soon as they are rendered on the server without having to wait for the whole page to be rendered. This will massively improve the FCP (First Contentful Paint) and FMP (First Meaningful Paint) metrics and reduce page load time in slower networks. This talk will demonstrate effective ways to progressively render a webpage from the server to the client and highlight important performance aspects of rendering modern websites.'
  },
  {
    name: 'Angie Jones',
    handle: 'techgirl1908',
    img: AngieImage,
    title: 'Your Tests Lack Vision: Adding Eyes to Your Automation Framework',
    description: 'Automation has come a long way in assisting with regression testing efforts. Teams worldwide are successfully running hundreds of functional regression tests at every check-in. While this provides a great source of confidence, critical regression bugs are still missed using this approach. That’s because these tests can only assert on what their human programmer asks them to. Additional errors with functionality, UX, and usability often go uncaught using today’s most common test automation techniques. For this reason, the top companies in all sectors of the industry are turning to visual validation. Visual validation is a relatively new concept that can be used to enhance existing automated tests and provide an easy way to perform those difficult checks for things like UX, localization, usability, responsive design, and cross-device testing. In this talk, you’ll learn how visual validation works, see an integration into an existing test code base, and discuss the pros and cons of using various visual validation techniques.'
  },
  {
    name: 'Alex Sexton',
    handle: 'SlexAxton',
    img: AlexImage,
    title: 'Advanced Design System Considerations',
    description: `"Design Systems" and component libraries are a popular solution for abstracting common UI elements and flows to be reusable across many applications.They allow you to spend more time on the details, and reduce the complexity of implementing consistent experiences.There's a good chance that you're using one already! Scaling these systems to provide value to *lots* of teams across your organization, or in open - source - land, requires solving for each team's different use-cases simultaneously. How do you add in support for internationalization, accessibility, theming (dark mode!), server rendering, or multiple render targets? How do you support the teams that need it in React *and* the teams that need it in Svelte? How do you provide a system that is flexible enough, but doesn't become prohibitively complex? How can you export your components to popular design tools for your designers to build with? Let's dive into approaches to solving these problems in scalable ways, and take a look at how Stripe has chosen to tackle some of these issues in the real world. Let's look at how to make sure a design system specifies design choices and allows users to build quickly, but doesn't lock you into specific frameworks or trendy tools out of the gate.`
  },
  {
    name: 'Lindsey Dragun ',
    handle: 'techevangelista',
    img: LindseyImage,
    title: 'Impactful Accessibility - The Changes That Mean The Most',
    description: "The sad truth is that even companies that wish to have accessible websites often only dedicate the time and effort to create SOME accessibility. What they choose to make accessible is often based on what a handful of people, often abled bodied ones, decide, and doesn’t always reflect what users want or need. Using a series of surveys and discussions with other disabled people, I have synthesized suggestions and examples of what makes the most impact for many users or gigantic impacts on usage for smaller groups.We'll go over the look, feel, and functionality of websites and some basic design changes that can be used to great benefit."
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  },
  {
    name: 'Placeholder'
  }
];